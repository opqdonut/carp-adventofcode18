(def in (IO.read-file "../input.13.txt"))
(def the-map (Array.pop-back (String.lines &in)))

(defn at [map coord]
  (let [x @(Pair.a coord)
        y @(Pair.b coord)]
    (do
      (if (and (and (<= 0 y) (< y (Array.length map)))
               (and (<= 0 x) (< x (String.length (Array.nth map y)))))
        (String.char-at (Array.nth map y) x)
        \#))))

(defn floor? [map coord]
  (not (= \# (at map coord))))

(defn neighbours [coord]
  (let [x @(Pair.a coord)
        y @(Pair.b coord)]
    [(Pair.init x (dec y))
     (Pair.init (dec x) y)
     (Pair.init (inc x) y)
     (Pair.init x (inc y))]))

(defn compare-coord [c1 c2]
  (if (= (Pair.b c1) (Pair.b c2))
    (> (Pair.a c1) (Pair.a c2))
    (> (Pair.b c1) (Pair.b c2))))

(defn bfs [map free? found? coords]
  (let [visited (Set.create)
        nexts (Array.sorted-by coords &compare-coord)
        dist 0
        found (Pair.init -1 -1)]
    (do
      (while true
        (do
          (let [founds (Array.filter found? @&nexts)]
            (unless (Array.empty? &founds)
              (do
                (set! found (Array.first &founds))
                (break))))
          (set! visited (Array.reduce &Set.put
                                      visited
                                      &nexts))
          (set! dist (inc dist))
          (let [candidates (Array.concat ;; TODO reduce instead
                            &(Array.copy-map
                              &(fn [coord] (Array.filter
                                            free?
                                            (neighbours coord)))
                              &(Set.to-array &visited)))
                visited-ref &visited
                new-nexts (Array.sort-by
                           (Array.filter
                            &(fn [coord] (not (Set.contains? visited-ref coord)))
                            candidates)
                           &compare-coord)]
            (set! nexts new-nexts))))
      (Pair.init dist found))))

(defn neighbouring? [c1 c2]
  (let [x1 @(Pair.a c1)
        y1 @(Pair.b c1)
        x2 @(Pair.a c2)
        y2 @(Pair.b c2)]
    (= 1
       (+ (Int.abs (- x1 x2))
          (Int.abs (- y1 y2))))))

(deftype Unit [type Char
               pos (Pair Int Int)])

(defn parse-units [map]
  (let [units []]
    (do
      (for [y 0 (Array.length map)]
        (let [line (Array.nth map y)]
          (for [x 0 (String.length line)]
            (let [c (String.char-at line x)]
              (when (or (= c \E)
                        (= c \G))
                (set! units (Array.push-back units (Unit.init c (Pair.init x y)))))))))
      units)))

(defn find-move [map units unit]
  (let [unit-positions (Array.copy-map &(fn [u] @(Unit.pos u)) units)
        obstructions (Set.from-array &unit-positions)
        obstructions-ref &obstructions
        free? (fn [c] (and (floor? map c)
                           (not (Set.contains? obstructions-ref c))))
        targets (Array.concat
                 &(Array.copy-map &(fn [u]
                                     (if (= (Unit.type u) (Unit.type unit))
                                       []
                                       (neighbours (Unit.pos u))))
                                  units))
        possible-next-move? (fn [c] (neighbouring? c (Unit.pos unit)))
        goal (bfs map &free? &possible-next-move? &targets)
        goal-dist @(Pair.a &goal)
        goal-coord @(Pair.b &goal)]
    (if (< goal-dist 0)
      @unit ;; don't move
      (Unit.set-pos @unit goal-coord))))

(defn tick [map units]
  (do
    (for [i 0 (Array.length &units)]
      (let [new (find-move map &units (Array.nth &units i))]
        (set! units (Array.aset units i new))))
    units))

(def test-map
  [@"#######"
   @"#.E.#.#"
   @"#E....#"
   @"#...G.#"
   @"#######"])

(def test-map-ref &test-map)

(defn main []
  (let [units (parse-units test-map-ref)]
    (do
      (println* &units)
      (println* &(tick test-map-ref units))
    )))
