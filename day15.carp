(def in (IO.read-file "../input.15.txt"))
(def the-map (Array.pop-back (String.lines &in)))

(defn at [map coord]
  (let [x @(Pair.a coord)
        y @(Pair.b coord)]
    (do
      (if (and (and (<= 0 y) (< y (Array.length map)))
               (and (<= 0 x) (< x (String.length (Array.nth map y)))))
        (String.char-at (Array.nth map y) x)
        \#))))

(defn floor? [map coord]
  (not (= \# (at map coord))))

(defn neighbours [coord]
  (let [x @(Pair.a coord)
        y @(Pair.b coord)]
    [(Pair.init x (dec y))
     (Pair.init (dec x) y)
     (Pair.init (inc x) y)
     (Pair.init x (inc y))]))

(defn compare-coord [c1 c2]
  (if (= (Pair.b c1) (Pair.b c2))
    (> (Pair.a c1) (Pair.a c2))
    (> (Pair.b c1) (Pair.b c2))))

;; TODO move to core
;; TODO could be reduce instead
(defn concat-map [f xs]
  (Array.concat
   &(Array.copy-map f xs)))

(defn bfs [map free? found? coords]
  (let [visited (Set.create)
        nexts (Array.sorted-by coords &compare-coord)
        dist 0
        found (Pair.init -1 -1)]
    (do
      (while true
        (do
          (when (Array.empty? &nexts)
            (do
              (set! dist -1)
              (break)))
          (let [founds (Array.filter found? @&nexts)]
            (unless (Array.empty? &founds)
              (do
                (set! found (Array.first &founds))
                (break))))
          (set! visited (Array.reduce &Set.put
                                      visited
                                      &nexts))
          (set! dist (inc dist))
          (let [candidates (concat-map
                            &(fn [coord] (Array.filter
                                          free?
                                          (neighbours coord)))
                            &(Set.to-array &visited))
                visited-ref &visited
                new-nexts (Array.sort-by
                           (Array.filter
                            &(fn [coord] (not (Set.contains? visited-ref coord)))
                            candidates)
                           &compare-coord)]
            (set! nexts new-nexts))))
      (Pair.init dist found))))

(defn neighbouring? [c1 c2]
  (let [x1 @(Pair.a c1)
        y1 @(Pair.b c1)
        x2 @(Pair.a c2)
        y2 @(Pair.b c2)]
    (= 1
       (+ (Int.abs (- x1 x2))
          (Int.abs (- y1 y2))))))

(deftype Unit [type Char
               pos (Pair Int Int)
               hp Int])

(defmodule UnitRef
  (sig = (Fn [(Ref Unit) (Ref Unit)] Bool))
  (defn = [u1 u2]
    (= (Unit.pos u1) (Unit.pos u2))))

(defn parse-units [map]
  (let [units []]
    (do
      (for [y 0 (Array.length map)]
        (let [line (Array.nth map y)]
          (for [x 0 (String.length line)]
            (let [c (String.char-at line x)]
              (when (or (= c \E)
                        (= c \G))
                (do
                  (String.string-set! line x \.)
                  (set! units (Array.push-back units (Unit.init c
                                                                (Pair.init x y)
                                                                200)))))))))
      units)))

(defn find-move [map units unit]
  (let [unit-positions (Array.copy-map &(fn [u] @(Unit.pos u)) units)
        obstructions (Set.from-array &unit-positions)
        obstructions-ref &obstructions
        free? (fn [c] (and (floor? map c)
                           (not (Set.contains? obstructions-ref c))))
        free?ref &free?
        targets (concat-map &(fn [u]
                               (if (= (Unit.type u) (Unit.type unit))
                                 []
                                 (neighbours (Unit.pos u))))
                            units)
        possible-next-move? (fn [c] (and (~free?ref c)
                                         (neighbouring? c (Unit.pos unit))))]
    (if (Array.any? &(fn [c] (= c (Unit.pos unit)))
                    &targets)
      @unit ;; no need to move
      (let [free-targets (Array.filter free?ref targets)
            goal (bfs map &free? &possible-next-move? &free-targets)
            goal-dist @(Pair.a &goal)
            goal-coord @(Pair.b &goal)]
        (if (< goal-dist 0)
          @unit ;; can't move
          (Unit.set-pos @unit goal-coord))))))

(defn compare-pos [u1 u2]
  (compare-coord (Unit.pos u1) (Unit.pos u2)))

(defn attack [units unit]
  (let [my-pos (Unit.pos unit)
        my-type (Unit.type unit)
        in-range (Array.filter &(fn [u] (and
                                         (not (= my-type (Unit.type u)))
                                         (neighbouring? my-pos (Unit.pos u))))
                               @&units)
        get-hp (fn [u] @(Unit.hp u))] ;; need to name this because of #361
    (if (Array.empty? &in-range)
      units ;; nothing happens
      (let [min-hp (Array.minimum &(the (Array Int) (Array.copy-map &get-hp
                                                                    &in-range)))
            min-hp-ref &min-hp
            min-hp-units (Array.filter &(fn [u] (= min-hp-ref (Unit.hp u)))
                                       in-range)
            selected (Array.first
                      &(Array.sort-by min-hp-units &compare-pos))
            selected-i (Array.index-of &units @&selected)] ;; TODO index-of should take ref
        (Array.aset units selected-i (Unit.set-hp selected (- min-hp 3)))))))

(defn alive? [u]
  (<= 0 @(Unit.hp u)))

(defn tick [map units]
  (do
    (set! units (Array.sort-by units &compare-pos))
    (for [i 0 (Array.length &units)]
      (let [old (Array.nth &units i)]
        (when (alive? old)
          (let [new (find-move map &units old)]
            (do
              (set! units (Array.aset units i @&new))
              (set! units (attack units &new)))))))
    (set! units (Array.filter &alive? units))
    units))

;; TODO to core?
(defn zero []
  \?)

(defn draw [map units]
  (let [by-pos (Map.from-array
                &(Array.copy-map
                  &(fn [u] (Pair.init-from-refs (Unit.pos u) (Unit.type u)))
                  units))]
    (for [y 0 (Array.length map)]
      (let [line (Array.nth map y)]
        (do
          (for [x 0 (String.length line)]
            (let [c (Pair.init x y)]
              (if (Map.contains? &by-pos &c)
                (print* (Map.get &by-pos &c))
                (print* (String.char-at line x)))))
          (println* ""))))))

(defn goblin? [u]
  (= \G @(Unit.type u)))

(defn part1 [map]
  (let [units (parse-units map)
        round -1]
    (do
      (while (not (Array.all? &goblin? &units))
        (do
          (set! units (tick map units))
          (set! round (inc round))))
      (println* round)
      (println* &units)
      (println* (* round
                   (Array.sum
                    &(Array.copy-map &(fn [u] @(Unit.hp u))
                                     &units)))))))

(def test-map-movement
  [@"#########"
   @"#G..G..G#"
   @"#.......#"
   @"#.......#"
   @"#G..E..G#"
   @"#.......#"
   @"#.......#"
   @"#G..G..G#"
   @"#########"])

(def test-map-1
  [@"#######"
   @"#.G...#"
   @"#...EG#"
   @"#.#.#G#"
   @"#..G#E#"
   @"#.....#"
   @"#######"])

(def test-map-2
  [@"#######"
   @"#E.G#.#"
   @"#.#G..#"
   @"#G.#.G#"
   @"#G..#.#"
   @"#...E.#"
   @"#######"])

(def test-map-3
  [@"#######"
   @"#.E...#"
   @"#.#..G#"
   @"#.###.#"
   @"#E#G#G#"
   @"#...#G#"
   @"#######"])

(def test-map-4
  [@"#########"
   @"#G......#"
   @"#.E.#...#"
   @"#..##..G#"
   @"#...##..#"
   @"#...#...#"
   @"#.G...G.#"
   @"#.....G.#"
   @"#########"])

(defn main []
  (do
    (part1 &test-map-1) ;; should be 27730
    (part1 &test-map-2) ;; should be 27755
    (part1 &test-map-3) ;; should be 28944
    (part1 &test-map-4) ;; should be 18740
    (part1 &the-map) ;; was 228582, too low
    ))
